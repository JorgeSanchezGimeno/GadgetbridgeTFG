/*  Copyright (C) 2023 Jos√© Rebelo, Andreas Shimokawa

    This file is part of Gadgetbridge.

    Gadgetbridge is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published
    by the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Gadgetbridge is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>. */
package nodomain.freeyourgadget.gadgetbridge.service.devices.xiaomi;


import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothGatt;
import android.bluetooth.BluetoothGattCharacteristic;
import android.content.Context;
import android.location.Location;
import android.net.Uri;
import android.widget.Toast;

import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import nodomain.freeyourgadget.gadgetbridge.BuildConfig;
import nodomain.freeyourgadget.gadgetbridge.GBApplication;
import nodomain.freeyourgadget.gadgetbridge.devices.xiaomi.XiaomiCoordinator;
import nodomain.freeyourgadget.gadgetbridge.devices.xiaomi.XiaomiFWHelper;
import nodomain.freeyourgadget.gadgetbridge.impl.GBDevice;
import nodomain.freeyourgadget.gadgetbridge.model.Alarm;
import nodomain.freeyourgadget.gadgetbridge.model.CalendarEventSpec;
import nodomain.freeyourgadget.gadgetbridge.model.CallSpec;
import nodomain.freeyourgadget.gadgetbridge.model.CannedMessagesSpec;
import nodomain.freeyourgadget.gadgetbridge.model.Contact;
import nodomain.freeyourgadget.gadgetbridge.model.MusicSpec;
import nodomain.freeyourgadget.gadgetbridge.model.MusicStateSpec;
import nodomain.freeyourgadget.gadgetbridge.model.NotificationSpec;
import nodomain.freeyourgadget.gadgetbridge.model.Reminder;
import nodomain.freeyourgadget.gadgetbridge.model.WeatherSpec;
import nodomain.freeyourgadget.gadgetbridge.model.WorldClock;
import nodomain.freeyourgadget.gadgetbridge.proto.xiaomi.XiaomiProto;
import nodomain.freeyourgadget.gadgetbridge.service.btle.AbstractBTLEDeviceSupport;
import nodomain.freeyourgadget.gadgetbridge.service.btle.TransactionBuilder;
import nodomain.freeyourgadget.gadgetbridge.service.btle.actions.SetDeviceStateAction;
import nodomain.freeyourgadget.gadgetbridge.service.devices.xiaomi.activity.XiaomiActivityFileId;
import nodomain.freeyourgadget.gadgetbridge.service.devices.xiaomi.activity.XiaomiActivityParser;
import nodomain.freeyourgadget.gadgetbridge.service.devices.xiaomi.services.AbstractXiaomiService;
import nodomain.freeyourgadget.gadgetbridge.service.devices.xiaomi.services.XiaomiCalendarService;
import nodomain.freeyourgadget.gadgetbridge.service.devices.xiaomi.services.XiaomiDataUploadService;
import nodomain.freeyourgadget.gadgetbridge.service.devices.xiaomi.services.XiaomiHealthService;
import nodomain.freeyourgadget.gadgetbridge.service.devices.xiaomi.services.XiaomiMusicService;
import nodomain.freeyourgadget.gadgetbridge.service.devices.xiaomi.services.XiaomiNotificationService;
import nodomain.freeyourgadget.gadgetbridge.service.devices.xiaomi.services.XiaomiPhonebookService;
import nodomain.freeyourgadget.gadgetbridge.service.devices.xiaomi.services.XiaomiScheduleService;
import nodomain.freeyourgadget.gadgetbridge.service.devices.xiaomi.services.XiaomiSystemService;
import nodomain.freeyourgadget.gadgetbridge.service.devices.xiaomi.services.XiaomiWatchfaceService;
import nodomain.freeyourgadget.gadgetbridge.service.devices.xiaomi.services.XiaomiWeatherService;
import nodomain.freeyourgadget.gadgetbridge.util.FileUtils;
import nodomain.freeyourgadget.gadgetbridge.util.GB;
import nodomain.freeyourgadget.gadgetbridge.util.Prefs;

public class XiaomiSupport extends AbstractBTLEDeviceSupport {
    private static final Logger LOG = LoggerFactory.getLogger(XiaomiSupport.class);

    protected XiaomiCharacteristic characteristicCommandRead;
    protected XiaomiCharacteristic characteristicCommandWrite;
    protected XiaomiCharacteristic characteristicActivityData;
    protected XiaomiCharacteristic characteristicDataUpload;

    protected final XiaomiAuthService authService = new XiaomiAuthService(this);
    protected final XiaomiMusicService musicService = new XiaomiMusicService(this);
    protected final XiaomiHealthService healthService = new XiaomiHealthService(this);
    protected final XiaomiNotificationService notificationService = new XiaomiNotificationService(this);
    protected final XiaomiScheduleService scheduleService = new XiaomiScheduleService(this);
    protected final XiaomiWeatherService weatherService = new XiaomiWeatherService(this);
    protected final XiaomiSystemService systemService = new XiaomiSystemService(this);
    protected final XiaomiCalendarService calendarService = new XiaomiCalendarService(this);
    protected final XiaomiWatchfaceService watchfaceService = new XiaomiWatchfaceService(this);
    protected final XiaomiDataUploadService dataUploadService = new XiaomiDataUploadService(this);
    protected final XiaomiPhonebookService phonebookService = new XiaomiPhonebookService(this);

    private String mFirmwareVersion = null;

    private final Map<Integer, AbstractXiaomiService> mServiceMap = new LinkedHashMap<Integer, AbstractXiaomiService>() {{
        put(XiaomiAuthService.COMMAND_TYPE, authService);
        put(XiaomiMusicService.COMMAND_TYPE, musicService);
        put(XiaomiHealthService.COMMAND_TYPE, healthService);
        put(XiaomiNotificationService.COMMAND_TYPE, notificationService);
        put(XiaomiScheduleService.COMMAND_TYPE, scheduleService);
        put(XiaomiWeatherService.COMMAND_TYPE, weatherService);
        put(XiaomiSystemService.COMMAND_TYPE, systemService);
        put(XiaomiCalendarService.COMMAND_TYPE, calendarService);
        put(XiaomiWatchfaceService.COMMAND_TYPE, watchfaceService);
        put(XiaomiDataUploadService.COMMAND_TYPE, dataUploadService);
        put(XiaomiPhonebookService.COMMAND_TYPE, phonebookService);
    }};

    public XiaomiSupport() {
        super(LOG);
        for (final UUID uuid : XiaomiBleUuids.UUIDS.keySet()) {
            addSupportedService(uuid);
        }
    }

    @Override
    protected final TransactionBuilder initializeDevice(final TransactionBuilder builder) {
        XiaomiBleUuids.XiaomiBleUuidSet uuidSet = null;
        BluetoothGattCharacteristic btCharacteristicCommandRead = null;
        BluetoothGattCharacteristic btCharacteristicCommandWrite = null;
        BluetoothGattCharacteristic btCharacteristicActivityData = null;
        BluetoothGattCharacteristic btCharacteristicDataUpload = null;

        // Attempt to find a known xiaomi service
        for (Map.Entry<UUID, XiaomiBleUuids.XiaomiBleUuidSet> xiaomiUuid : XiaomiBleUuids.UUIDS.entrySet()) {
            if (getSupportedServices().contains(xiaomiUuid.getKey())) {
                LOG.debug("Found Xiaomi service: {}", xiaomiUuid.getKey());
                uuidSet = xiaomiUuid.getValue();

                btCharacteristicCommandRead = getCharacteristic(uuidSet.getCharacteristicCommandRead());
                btCharacteristicCommandWrite = getCharacteristic(uuidSet.getCharacteristicCommandWrite());
                btCharacteristicActivityData = getCharacteristic(uuidSet.getCharacteristicActivityData());
                btCharacteristicDataUpload = getCharacteristic(uuidSet.getCharacteristicDataUpload());
                if (btCharacteristicCommandRead == null) {
                    LOG.warn("btCharacteristicCommandRead characteristicc is null");
                    continue;
                } else if (btCharacteristicCommandWrite == null) {
                    LOG.warn("btCharacteristicCommandWrite characteristicc is null");
                    continue;
                } else if (btCharacteristicActivityData == null) {
                    LOG.warn("btCharacteristicActivityData characteristicc is null");
                    continue;
                } else if (btCharacteristicDataUpload == null) {
                    LOG.warn("btCharacteristicDataUpload characteristicc is null");
                    continue;
                }

                break;
            }
        }

        if (uuidSet == null) {
            GB.toast(getContext(), "Failed to find known Xiaomi service", Toast.LENGTH_LONG, GB.ERROR);
            LOG.warn("Failed to find known Xiaomi service");
            builder.add(new SetDeviceStateAction(getDevice(), GBDevice.State.NOT_CONNECTED, getContext()));
            return builder;
        }

        // FIXME unsetDynamicState unsets the fw version, which causes problems..
        if (getDevice().getFirmwareVersion() == null && mFirmwareVersion != null) {
            getDevice().setFirmwareVersion(mFirmwareVersion);
        }

        if (btCharacteristicCommandRead == null || btCharacteristicCommandWrite == null) {
            LOG.warn("Characteristics are null, will attempt to reconnect");
            builder.add(new SetDeviceStateAction(getDevice(), GBDevice.State.WAITING_FOR_RECONNECT, getContext()));
            return builder;
        }

        this.characteristicCommandRead = new XiaomiCharacteristic(this, btCharacteristicCommandRead, authService);
        this.characteristicCommandRead.setEncrypted(uuidSet.isEncrypted());
        this.characteristicCommandRead.setHandler(this::handleCommandBytes);
        this.characteristicCommandWrite = new XiaomiCharacteristic(this, btCharacteristicCommandWrite, authService);
        this.characteristicCommandWrite.setEncrypted(uuidSet.isEncrypted());
        this.characteristicActivityData = new XiaomiCharacteristic(this, btCharacteristicActivityData, authService);
        this.characteristicActivityData.setHandler(healthService.getActivityFetcher()::addChunk);
        this.characteristicActivityData.setEncrypted(uuidSet.isEncrypted());
        this.characteristicDataUpload = new XiaomiCharacteristic(this, btCharacteristicDataUpload, authService);
        this.characteristicDataUpload.setEncrypted(uuidSet.isEncrypted());
        this.characteristicDataUpload.setIncrementNonce(false);
        this.dataUploadService.setDataUploadCharacteristic(this.characteristicDataUpload);

        builder.requestMtu(247);

        builder.add(new SetDeviceStateAction(getDevice(), GBDevice.State.INITIALIZING, getContext()));

        builder.notify(btCharacteristicCommandWrite, true);
        builder.notify(btCharacteristicCommandRead, true);
        builder.notify(btCharacteristicActivityData, true);
        builder.notify(btCharacteristicDataUpload, true);

        if (uuidSet.isEncrypted()) {
            authService.startEncryptedHandshake(builder);
        } else {
            authService.startClearTextHandshake(builder);
        }

        return builder;
    }

    @Override
    public boolean useAutoConnect() {
        return true;
    }

    @Override
    public boolean getImplicitCallbackModify() {
        return false;
    }

    @Override
    public void setContext(final GBDevice gbDevice, final BluetoothAdapter btAdapter, final Context context) {
        // FIXME unsetDynamicState unsets the fw version, which causes problems..
        if (mFirmwareVersion == null && gbDevice.getFirmwareVersion() != null) {
            mFirmwareVersion = gbDevice.getFirmwareVersion();
        }

        super.setContext(gbDevice, btAdapter, context);
        for (final AbstractXiaomiService service : mServiceMap.values()) {
            service.setContext(context);
        }
    }

    @Override
    public boolean onCharacteristicChanged(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic) {
        if (super.onCharacteristicChanged(gatt, characteristic)) {
            return true;
        }

        final UUID characteristicUUID = characteristic.getUuid();
        final byte[] value = characteristic.getValue();

        if (characteristicCommandRead.getCharacteristicUUID().equals(characteristicUUID)) {
            characteristicCommandRead.onCharacteristicChanged(value);
            return true;
        } else if (characteristicCommandWrite.getCharacteristicUUID().equals(characteristicUUID)) {
            characteristicCommandWrite.onCharacteristicChanged(value);
            return true;
        } else if (characteristicActivityData.getCharacteristicUUID().equals(characteristicUUID)) {
            characteristicActivityData.onCharacteristicChanged(value);
            return true;
        } else if (characteristicDataUpload.getCharacteristicUUID().equals(characteristicUUID)) {
            characteristicDataUpload.onCharacteristicChanged(value);
            return true;
        }

        LOG.warn("Unhandled characteristic changed: {} {}", characteristicUUID, GB.hexdump(value));
        return false;
    }

    public void handleCommandBytes(final byte[] plainValue) {
        LOG.debug("Got command: {}", GB.hexdump(plainValue));

        final XiaomiProto.Command cmd;
        try {
            cmd = XiaomiProto.Command.parseFrom(plainValue);
        } catch (final Exception e) {
            LOG.error("Failed to parse bytes as protobuf command payload", e);
            return;
        }

        final AbstractXiaomiService service = mServiceMap.get(cmd.getType());
        if (service != null) {
            service.handleCommand(cmd);
            return;
        }

        LOG.warn("Unexpected watch command type {}", cmd.getType());
    }

    @Override
    public void onSendConfiguration(final String config) {
        final Prefs prefs = getDevicePrefs();

        // Check if any of the services handles this config
        for (final AbstractXiaomiService service : mServiceMap.values()) {
            if (service.onSendConfiguration(config, prefs)) {
                return;
            }
        }

        LOG.warn("Unhandled config changed: {}", config);
    }

    @Override
    public void onSetTime() {
        systemService.setCurrentTime();

        if (getCoordinator().supportsCalendarEvents()) {
            // TODO this should not be done here
            calendarService.syncCalendar();
        }
    }

    @Override
    public void onTestNewFunction() {
        //sendCommand("test new function", 2, 29);
        parseAllActivityFilesFromStorage();
    }

    @Override
    public void onFindPhone(final boolean start) {
        systemService.onFindPhone(start);
    }

    @Override
    public void onFindDevice(final boolean start) {
        systemService.onFindWatch(start);
    }

    @Override
    public void onSetPhoneVolume(final float volume) {
        musicService.onSetPhoneVolume(volume);
    }

    @Override
    public void onSetGpsLocation(final Location location) {
        healthService.onSetGpsLocation(location);
    }

    @Override
    public void onSetReminders(final ArrayList<? extends Reminder> reminders) {
        scheduleService.onSetReminders(reminders);
    }

    @Override
    public void onSetWorldClocks(final ArrayList<? extends WorldClock> clocks) {
        scheduleService.onSetWorldClocks(clocks);
    }

    @Override
    public void onNotification(final NotificationSpec notificationSpec) {
        notificationService.onNotification(notificationSpec);
    }

    @Override
    public void onDeleteNotification(final int id) {
        notificationService.onDeleteNotification(id);
    }

    @Override
    public void onSetAlarms(final ArrayList<? extends Alarm> alarms) {
        scheduleService.onSetAlarms(alarms);
    }

    @Override
    public void onSetCallState(final CallSpec callSpec) {
        notificationService.onSetCallState(callSpec);
    }

    @Override
    public void onSetCannedMessages(final CannedMessagesSpec cannedMessagesSpec) {
        notificationService.onSetCannedMessages(cannedMessagesSpec);
    }

    @Override
    public void onSetMusicState(final MusicStateSpec stateSpec) {
        musicService.onSetMusicState(stateSpec);
    }

    @Override
    public void onSetMusicInfo(final MusicSpec musicSpec) {
        musicService.onSetMusicInfo(musicSpec);
    }

    @Override
    public void onInstallApp(final Uri uri) {
        final XiaomiFWHelper fwHelper = new XiaomiFWHelper(uri, getContext());

        if (!fwHelper.isValid()) {
            LOG.warn("Uri {} is not valid", uri);
            return;
        }

        if (fwHelper.isFirmware()) {
            systemService.installFirmware(fwHelper);
        } else if (fwHelper.isWatchface()) {
            watchfaceService.installWatchface(fwHelper);
        } else {
            LOG.warn("Unknown fwhelper for {}", uri);
        }
    }

    @Override
    public void onAppInfoReq() {
        watchfaceService.requestWatchfaceList();
    }

    @Override
    public void onAppStart(final UUID uuid, boolean start) {
        if (start) {
            watchfaceService.setWatchface(uuid);
        }
    }

    @Override
    public void onAppDelete(final UUID uuid) {
        watchfaceService.deleteWatchface(uuid);
    }

    @Override
    public void onFetchRecordedData(final int dataTypes) {
        healthService.onFetchRecordedData(dataTypes);
    }

    @Override
    public void onHeartRateTest() {
        healthService.onHeartRateTest();
    }

    @Override
    public void onEnableRealtimeHeartRateMeasurement(final boolean enable) {
        healthService.enableRealtimeStats(enable);
    }

    @Override
    public void onEnableRealtimeSteps(final boolean enable) {
        healthService.enableRealtimeStats(enable);
    }

    @Override
    public void onEnableHeartRateSleepSupport(final boolean enable) {
        healthService.setHeartRateConfig();
    }

    @Override
    public void onSetHeartRateMeasurementInterval(final int seconds) {
        healthService.setHeartRateConfig();
    }

    @Override
    public void onAddCalendarEvent(final CalendarEventSpec calendarEventSpec) {
        calendarService.onAddCalendarEvent(calendarEventSpec);
    }

    @Override
    public void onDeleteCalendarEvent(final byte type, long id) {
        calendarService.onDeleteCalendarEvent(type, id);
    }

    @Override
    public void onSendWeather(final WeatherSpec weatherSpec) {
        weatherService.onSendWeather(weatherSpec);
    }

    @Override
    public void onSetContacts(ArrayList<? extends Contact> contacts) {
        phonebookService.setContacts((List<Contact>) contacts);
    }

    public XiaomiCoordinator getCoordinator() {
        return (XiaomiCoordinator) gbDevice.getDeviceCoordinator();
    }

    protected void phase2Initialize() {
        LOG.info("phase2Initialize");

        characteristicCommandRead.reset();
        characteristicCommandWrite.reset();
        characteristicActivityData.reset();
        characteristicDataUpload.reset();

        if (GBApplication.getPrefs().getBoolean("datetime_synconconnect", true)) {
            systemService.setCurrentTime();
        }

        for (final AbstractXiaomiService service : mServiceMap.values()) {
            service.initialize();
        }
    }

    public void sendCommand(final String taskName, final XiaomiProto.Command command) {
        if (this.characteristicCommandWrite == null) {
            // Can sometimes happen in race conditions when connecting + receiving calendar event or weather updates
            LOG.warn("characteristicCommandWrite is null!");
            return;
        }

        this.characteristicCommandWrite.write(taskName, command.toByteArray());
    }

    /**
     * Realistically, this function should only be used during auth, as we must schedule the command after
     * notifications were enabled on the characteristics, and for that we need the builder to guarantee the
     * order.
     */
    public void sendCommand(final TransactionBuilder builder, final XiaomiProto.Command command) {
        if (this.characteristicCommandWrite == null) {
            // Can sometimes happen in race conditions when connecting + receiving calendar event or weather updates
            LOG.warn("characteristicCommandWrite is null!");
            return;
        }

        this.characteristicCommandWrite.write(builder, command.toByteArray());
    }

    public void sendCommand(final String taskName, final int type, final int subtype) {
        sendCommand(
                taskName,
                XiaomiProto.Command.newBuilder()
                        .setType(type)
                        .setSubtype(subtype)
                        .build()
        );
    }

    public XiaomiDataUploadService getDataUploader() {
        return this.dataUploadService;
    }

    @Override
    public String customStringFilter(final String inputString) {
        return StringUtils.replaceEach(inputString, EMOJI_SOURCE, EMOJI_TARGET);
    }

    private void parseAllActivityFilesFromStorage() {
        // This function as-is should only be used for debug purposes
        if (!BuildConfig.DEBUG) {
            LOG.error("This should never be used in release builds");
            return;
        }

        LOG.info("Parsing all activity files from storage");

        try {
            final File externalFilesDir = FileUtils.getExternalFilesDir();
            final File targetDir = new File(externalFilesDir, "rawFetchOperations");

            if (!targetDir.exists()) {
                LOG.warn("rawFetchOperations not found");
                return;
            }

            final File[] activityFiles = targetDir.listFiles((dir, name) -> name.startsWith("xiaomi_"));

            if (activityFiles == null) {
                LOG.warn("activityFiles is null");
                return;
            }

            for (final File activityFile : activityFiles) {
                LOG.debug("Parsing {}", activityFile);

                // The logic below just replicates XiaomiActivityFileFetcher

                final byte[] data;
                try (InputStream in = new FileInputStream(activityFile)) {
                    data = FileUtils.readAll(in, 999999);
                } catch (final IOException ioe) {
                    LOG.error("Failed to read " + activityFile, ioe);
                    continue;
                }

                final byte[] fileIdBytes = Arrays.copyOfRange(data, 0, 7);
                final byte[] activityData = Arrays.copyOfRange(data, 8, data.length - 4);
                final XiaomiActivityFileId fileId = XiaomiActivityFileId.from(fileIdBytes);

                final XiaomiActivityParser activityParser = XiaomiActivityParser.create(fileId);
                if (activityParser == null) {
                    LOG.warn("Failed to find parser for {}", fileId);
                    continue;
                }

                try {
                    if (activityParser.parse(this, fileId, activityData)) {
                        LOG.info("Successfully parsed {}", fileId);
                    } else {
                        LOG.warn("Failed to parse {}", fileId);
                    }
                } catch (final Exception ex) {
                    LOG.error("Exception while parsing " + fileId, ex);
                }
            }
        } catch (final Exception e) {
            LOG.error("Failed to parse from storage", e);
        }
    }

    private static final String[] EMOJI_SOURCE = new String[]{
            "\uD83D\uDE0D", // üòç
            "\uD83D\uDE18", // üòò
            "\uD83D\uDE02", // üòÇ
            "\uD83D\uDE0A", // üòä
            "\uD83D\uDE0E", // üòé
            "\uD83D\uDE09", // üòâ
            "\uD83D\uDC8B", // üíã
            "\uD83D\uDC4D", // üëç
            "\uD83E\uDD23", // ü§£
            "\uD83D\uDC95", // üíï
            "\uD83D\uDE00", // üòÄ
            "\uD83D\uDE04", // üòÑ
            "\uD83D\uDE2D", // üò≠
            "\uD83E\uDD7A", // ü•∫
            "\uD83D\uDE4F", // üôè
            "\uD83E\uDD70", // ü•∞
            "\uD83E\uDD14", // ü§î
            "\uD83D\uDD25", // üî•
            "\uD83D\uDE29", // üò©
            "\uD83D\uDE14", // üòî
            "\uD83D\uDE01", // üòÅ
            "\uD83D\uDC4C", // üëå
            "\uD83D\uDE0F", // üòè
            "\uD83D\uDE05", // üòÖ
            "\uD83E\uDD0D", // ü§ç
            "\uD83D\uDC94", // üíî
            "\uD83D\uDE0C", // üòå
            "\uD83D\uDE22", // üò¢
            "\uD83D\uDC99", // üíô
            "\uD83D\uDC9C", // üíú
            "\uD83C\uDFB6", // üé∂
            "\uD83D\uDE33", // üò≥
            "\uD83D\uDC96", // üíñ
            "\uD83D\uDE4C", // üôå
            "\uD83D\uDCAF", // üíØ
            "\uD83D\uDE48", // üôà
            "\uD83D\uDE0B", // üòã
            "\uD83D\uDE11", // üòë
            "\uD83D\uDE34", // üò¥
            "\uD83D\uDE2A", // üò™
            "\uD83D\uDE1C", // üòú
            "\uD83D\uDE1B", // üòõ
            "\uD83D\uDE1D", // üòù
            "\uD83D\uDE1E", // üòû
            "\uD83D\uDE15", // üòï
            "\uD83D\uDC97", // üíó
            "\uD83D\uDC4F", // üëè
            "\uD83D\uDE10", // üòê
            "\uD83D\uDC49", // üëâ
            "\uD83D\uDC9B", // üíõ
            "\uD83D\uDC9E", // üíû
            "\uD83D\uDCAA", // üí™
            "\uD83C\uDF39", // üåπ
            "\uD83D\uDC80", // üíÄ
            "\uD83D\uDE31", // üò±
            "\uD83D\uDC98", // üíò
            "\uD83E\uDD1F", // ü§ü
            "\uD83D\uDE21", // üò°
            "\uD83D\uDCF7", // üì∑
            "\uD83C\uDF38", // üå∏
            "\uD83D\uDE08", // üòà
            "\uD83D\uDC48", // üëà
            "\uD83C\uDF89", // üéâ
            "\uD83D\uDC81", // üíÅ
            "\uD83D\uDE4A", // üôä
            "\uD83D\uDC9A", // üíö
            "\uD83D\uDE2B", // üò´
            "\uD83D\uDE24", // üò§
            "\uD83D\uDC93", // üíì
            "\uD83C\uDF1A", // üåö
            "\uD83D\uDC47", // üëá
            "\uD83D\uDE07", // üòá
            "\uD83D\uDC4A", // üëä
            "\uD83D\uDC51", // üëë
            "\uD83D\uDE13", // üòì
            "\uD83D\uDE3B", // üòª
            "\uD83D\uDD34", // üî¥
            "\uD83D\uDE25", // üò•
            "\uD83E\uDD29", // ü§©
            "\uD83D\uDE1A", // üòö
            "\uD83D\uDE37", // üò∑
            "\uD83D\uDC4B", // üëã
            "\uD83D\uDCA5", // üí•
            "\uD83E\uDD2D", // ü§≠
            "\uD83C\uDF1F", // üåü
            "\uD83E\uDD71", // ü•±
            "\uD83D\uDCA9", // üí©
            "\uD83D\uDE80", // üöÄ
    };

    private static final String[] EMOJI_TARGET = new String[]{
            "ÍÄÇ", // üòç
            "ÍÄÉ", // üòò
            "ÍÄÑ", // üòÇ
            "ÍÄÖ", // üòä
            "ÍÄÜ", // üòé
            "ÍÄá", // üòâ
            "ÍÄà", // üíã
            "ÍÄâ", // üëç
            "ÍÄä", // ü§£
            "ÍÄã", // üíï
            "ÍÄå", // üòÄ
            "ÍÄç", // üòÑ
            "ÍÄé", // üò≠
            "ÍÄè", // ü•∫
            "ÍÄë", // üôè
            "ÍÄí", // ü•∞
            "ÍÄì", // ü§î
            "ÍÄî", // üî•
            "ÍÄó", // üò©
            "ÍÄò", // üòî
            "ÍÄô", // üòÅ
            "ÍÄö", // üëå
            "ÍÄõ", // üòè
            "ÍÄú", // üòÖ
            "ÍÄù", // ü§ç
            "ÍÄû", // üíî
            "ÍÄü", // üòå
            "ÍÄ†", // üò¢
            "ÍÄ°", // üíô
            "ÍÄ¢", // üíú
            "ÍÄ§", // üé∂
            "ÍÄ•", // üò≥
            "ÍÄ¶", // üíñ
            "ÍÄß", // üôå
            "ÍÄ®", // üíØ
            "ÍÄ©", // üôà
            "ÍÄ´", // üòã
            "ÍÄ¨", // üòë
            "ÍÄ≠", // üò¥
            "ÍÄÆ", // üò™
            "ÍÄØ", // üòú
            "ÍÄ∞", // üòõ
            "ÍÄ±", // üòù
            "ÍÄ≤", // üòû
            "ÍÄ≥", // üòï
            "ÍÄ¥", // üíó
            "ÍÄµ", // üëè
            "ÍÄ∂", // üòê
            "ÍÄ∑", // üëâ
            "ÍÄ∏", // üíõ
            "ÍÄπ", // üíû
            "ÍÄ∫", // üí™
            "ÍÄª", // üåπ
            "ÍÄº", // üíÄ
            "ÍÄΩ", // üò±
            "ÍÄæ", // üíò
            "ÍÄø", // ü§ü
            "ÍÅÄ", // üò°
            "ÍÅÅ", // üì∑
            "ÍÅÇ", // üå∏
            "ÍÅÉ", // üòà
            "ÍÅÑ", // üëà
            "ÍÅÖ", // üéâ
            "ÍÅÜ", // üíÅ
            "ÍÅá", // üôä
            "ÍÅà", // üíö
            "ÍÅâ", // üò´
            "ÍÅä", // üò§
            "ÍÅç", // üíì
            "ÍÅé", // üåö
            "ÍÅè", // üëá
            "ÍÅí", // üòá
            "ÍÅì", // üëä
            "ÍÅî", // üëë
            "ÍÅï", // üòì
            "ÍÅñ", // üòª
            "ÍÅó", // üî¥
            "ÍÅò", // üò•
            "ÍÅô", // ü§©
            "ÍÅö", // üòö
            "ÍÅú", // üò∑
            "ÍÅù", // üëã
            "ÍÅû", // üí•
            "ÍÅ†", // ü§≠
            "ÍÅ°", // üåü
            "ÍÅ¢", // ü•±
            "ÍÅ£", // üí©
            "ÍÅ§", // üöÄ
    };
}
